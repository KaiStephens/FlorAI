"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/components/PlanetScene.tsx":
/*!****************************************!*\
  !*** ./src/components/PlanetScene.tsx ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ PlanetScene; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\nfunction PlanetScene() {\n    _s();\n    const containerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!containerRef.current) return;\n        // Scene setup\n        const scene = new three__WEBPACK_IMPORTED_MODULE_2__.Scene();\n        // Add fog for depth\n        scene.fog = new three__WEBPACK_IMPORTED_MODULE_2__.FogExp2(0x000511, 0.01);\n        // Use a wider field of view to capture more of the scene\n        const camera = new three__WEBPACK_IMPORTED_MODULE_2__.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);\n        // Enhanced renderer with better shadows\n        const renderer = new three__WEBPACK_IMPORTED_MODULE_2__.WebGLRenderer({\n            antialias: true,\n            alpha: true\n        });\n        renderer.setSize(window.innerWidth, window.innerHeight);\n        renderer.setClearColor(0x000511);\n        renderer.toneMapping = three__WEBPACK_IMPORTED_MODULE_2__.ACESFilmicToneMapping;\n        renderer.toneMappingExposure = 1.2;\n        containerRef.current.appendChild(renderer.domElement);\n        // Enhanced Lighting\n        const ambientLight = new three__WEBPACK_IMPORTED_MODULE_2__.AmbientLight(0xffffff, 0.8);\n        scene.add(ambientLight);\n        const pointLight = new three__WEBPACK_IMPORTED_MODULE_2__.PointLight(0xffffff, 2);\n        pointLight.position.set(25, 5, 15); // Position light to illuminate planet from right\n        scene.add(pointLight);\n        // Add a second point light for better illumination\n        const pointLight2 = new three__WEBPACK_IMPORTED_MODULE_2__.PointLight(0xc4f1de, 1.5);\n        pointLight2.position.set(-10, -5, -5);\n        scene.add(pointLight2);\n        // Create stars - simple and spread throughout the scene\n        const createStarField = ()=>{\n            const starCount = 3000;\n            const geometry = new three__WEBPACK_IMPORTED_MODULE_2__.BufferGeometry();\n            const positions = new Float32Array(starCount * 3);\n            // Create stars with a wider distribution\n            for(let i = 0; i < starCount; i++){\n                // Distribute stars in a cube formation that extends well beyond the camera view\n                positions[i * 3] = (Math.random() - 0.5) * 200;\n                positions[i * 3 + 1] = (Math.random() - 0.5) * 200;\n                positions[i * 3 + 2] = (Math.random() - 0.5) * 200;\n            }\n            geometry.setAttribute(\"position\", new three__WEBPACK_IMPORTED_MODULE_2__.BufferAttribute(positions, 3));\n            // Use a single star size instead of different sizes\n            const material = new three__WEBPACK_IMPORTED_MODULE_2__.PointsMaterial({\n                color: 0xffffff,\n                size: 0.2,\n                transparent: true,\n                opacity: 0.8\n            });\n            const stars = new three__WEBPACK_IMPORTED_MODULE_2__.Points(geometry, material);\n            scene.add(stars);\n            return [\n                stars\n            ]; // Return as an array to maintain compatibility with animation code\n        };\n        const starGroups = createStarField();\n        // Create planet (on the right side)\n        const planetGeometry = new three__WEBPACK_IMPORTED_MODULE_2__.SphereGeometry(12, 64, 64);\n        const planetMaterial = new three__WEBPACK_IMPORTED_MODULE_2__.MeshPhongMaterial({\n            map: new three__WEBPACK_IMPORTED_MODULE_2__.TextureLoader().load(\"https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/planets/earth_atmos_2048.jpg\"),\n            bumpMap: new three__WEBPACK_IMPORTED_MODULE_2__.TextureLoader().load(\"https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/planets/earth_normal_2048.jpg\"),\n            bumpScale: 0.05,\n            specularMap: new three__WEBPACK_IMPORTED_MODULE_2__.TextureLoader().load(\"https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/planets/earth_specular_2048.jpg\"),\n            specular: new three__WEBPACK_IMPORTED_MODULE_2__.Color(\"grey\"),\n            shininess: 15\n        });\n        const planet = new three__WEBPACK_IMPORTED_MODULE_2__.Mesh(planetGeometry, planetMaterial);\n        scene.add(planet);\n        // Add plant-like atmosphere\n        const atmosphereGeometry = new three__WEBPACK_IMPORTED_MODULE_2__.SphereGeometry(12.4, 64, 64);\n        const atmosphereMaterial = new three__WEBPACK_IMPORTED_MODULE_2__.ShaderMaterial({\n            transparent: true,\n            side: three__WEBPACK_IMPORTED_MODULE_2__.BackSide,\n            vertexShader: \"\\n                varying vec3 vNormal;\\n                void main() {\\n                    vNormal = normalize(normalMatrix * normal);\\n                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\\n                }\\n            \",\n            fragmentShader: \"\\n                varying vec3 vNormal;\\n                void main() {\\n                    float intensity = pow(0.7 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 2.0);\\n                    gl_FragColor = vec4(0.4, 0.8, 0.4, 1.0) * intensity;\\n                }\\n            \"\n        });\n        const atmosphere = new three__WEBPACK_IMPORTED_MODULE_2__.Mesh(atmosphereGeometry, atmosphereMaterial);\n        scene.add(atmosphere);\n        // Camera position - adjusted for the much larger and further-right planet\n        camera.position.set(-20, 0, 25);\n        // Look at a point much further to the right\n        camera.lookAt(new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(60, 0, 0));\n        // Animation\n        // Track target positions for smoother interpolation\n        let targetX = 20;\n        let targetZ = 30;\n        let targetRotationY = 0.5; // Add target rotation for smooth transitions\n        const interpolationSpeed = 0.05; // Controls smoothness of transitions\n        // Track direction for z-position oscillation\n        let zDirectionForward = true; // true = moving toward viewer (decreasing z), false = moving away\n        let autoOscillate = false; // Will be set to true once target reaches a boundary\n        const oscillationSpeed = 0.1; // Speed of automatic back-and-forth movement\n        function animate() {\n            requestAnimationFrame(animate);\n            // Smoothly interpolate current position toward target position\n            const currentX = planet.position.x;\n            const currentZ = planet.position.z;\n            // Interpolate X position (right movement)\n            if (Math.abs(targetX - currentX) > 0.01) {\n                planet.position.x += (targetX - currentX) * interpolationSpeed;\n            }\n            // Handle z-position oscillation\n            if (autoOscillate) {\n                // Automatically move in current direction\n                if (zDirectionForward) {\n                    targetZ -= oscillationSpeed;\n                    if (targetZ <= 0) {\n                        targetZ = 0;\n                        zDirectionForward = false; // Reverse direction\n                    }\n                } else {\n                    targetZ += oscillationSpeed;\n                    if (targetZ >= 30) {\n                        targetZ = 30;\n                        zDirectionForward = true; // Reverse direction\n                    }\n                }\n            } else {\n                // Check if we've reached a boundary and should start auto-oscillation\n                if (targetZ <= 0.1) {\n                    zDirectionForward = false; // Start moving away\n                    autoOscillate = true; // Begin auto-oscillation\n                } else if (targetZ >= 29.9) {\n                    zDirectionForward = true; // Start moving toward viewer\n                    autoOscillate = true; // Begin auto-oscillation\n                }\n            }\n            // Interpolate Z position (distance)\n            if (Math.abs(targetZ - currentZ) > 0.01) {\n                planet.position.z += (targetZ - currentZ) * interpolationSpeed;\n            }\n            // Interpolate rotation for smooth transitions\n            const rotationDelta = targetRotationY - planet.rotation.y;\n            if (Math.abs(rotationDelta) > 0.01) {\n                planet.rotation.y += rotationDelta * interpolationSpeed;\n                atmosphere.rotation.y = planet.rotation.y;\n            }\n            // Keep atmosphere with planet\n            atmosphere.position.copy(planet.position);\n            // Rotate star fields slightly for subtle movement\n            starGroups.forEach((stars, i)=>{\n                stars.rotation.y += 0.0001 * (i + 1);\n                stars.rotation.x += 0.00005 * (i + 1);\n            });\n            renderer.render(scene, camera);\n        }\n        // Handle wheel events for rotation - this is more direct than scroll\n        const handleWheel = (event)=>{\n            // Determine direction and force of wheel event\n            const delta = event.deltaY;\n            // Apply rotation directly to the planet (via target)\n            targetRotationY += delta * 0.002;\n            // Check scroll direction - manual control temporarily overrides auto-oscillation\n            if (delta > 0) {\n                // Scrolling down - move planet closer (decrease z) - faster\n                autoOscillate = false; // Disable auto-oscillation during manual control\n                zDirectionForward = true; // Set direction toward viewer\n                if (targetZ > 0) {\n                    // Decrease z proportional to rotation amount but always moving forward\n                    const zDelta = Math.abs(delta) * 0.03;\n                    targetZ = Math.max(0, targetZ - zDelta);\n                }\n            } else if (delta < 0) {\n                // Scrolling up - move planet farther (increase z)\n                autoOscillate = false; // Disable auto-oscillation during manual control\n                zDirectionForward = false; // Set direction away from viewer\n                if (targetZ < 30) {\n                    // Increase z proportional to rotation amount\n                    const zDelta = Math.abs(delta) * 0.03;\n                    targetZ = Math.min(30, targetZ + zDelta);\n                }\n            }\n        };\n        // Track touch position for mobile devices\n        let touchStartY = 0;\n        // Handle touch events for mobile\n        const handleTouchStart = (event)=>{\n            touchStartY = event.touches[0].clientY;\n        };\n        const handleTouchMove = (event)=>{\n            // Skip if no starting position\n            if (touchStartY === 0) return;\n            // Calculate delta (negative to match wheel direction)\n            const touchDelta = -(event.touches[0].clientY - touchStartY) * 10;\n            // Apply rotation just like with wheel events\n            targetRotationY += touchDelta * 0.002;\n            // Check scroll direction - manual control temporarily overrides auto-oscillation\n            if (touchDelta > 0) {\n                // Scrolling down - move planet closer (decrease z)\n                autoOscillate = false; // Disable auto-oscillation during manual control\n                zDirectionForward = true; // Set direction toward viewer\n                if (targetZ > 0) {\n                    // Decrease z proportional to rotation amount\n                    const zDelta = Math.abs(touchDelta) * 0.03;\n                    targetZ = Math.max(0, targetZ - zDelta);\n                }\n            } else if (touchDelta < 0) {\n                // Scrolling up - move planet farther (increase z)\n                autoOscillate = false; // Disable auto-oscillation during manual control\n                zDirectionForward = false; // Set direction away from viewer\n                if (targetZ < 30) {\n                    // Increase z proportional to rotation amount\n                    const zDelta = Math.abs(touchDelta) * 0.03;\n                    targetZ = Math.min(30, targetZ + zDelta);\n                }\n            }\n            // Update start position\n            touchStartY = event.touches[0].clientY;\n        };\n        const handleTouchEnd = ()=>{\n            touchStartY = 0;\n        };\n        // Handle scroll events to update planet position\n        const handleScroll = ()=>{\n            // Get current scroll position as percentage of page height\n            const scrollHeight = document.documentElement.scrollHeight - window.innerHeight;\n            const scrollTop = window.scrollY || document.documentElement.scrollTop;\n            const scrollPercent = Math.min(scrollTop / scrollHeight, 1);\n            // Calculate x-position: 20 at top of page, gradually increasing to 100 as we scroll\n            let xPos = 20;\n            if (scrollPercent > 0.1) {\n                // Map 10%-30% scroll to full x-position change (20 to 100) - much faster\n                // Decreased from 0.4 to 0.2 to make it move even faster\n                const xScrollPercent = Math.min((scrollPercent - 0.1) / 0.2, 1);\n                xPos = 20 + 80 * xScrollPercent; // Move from 20 to 100\n            }\n            // Update target X position - actual movement happens in animation loop\n            targetX = xPos;\n        };\n        // Handle window resize\n        const handleResize = ()=>{\n            camera.aspect = window.innerWidth / window.innerHeight;\n            camera.updateProjectionMatrix();\n            renderer.setSize(window.innerWidth, window.innerHeight);\n            // Update planet position on resize too\n            handleScroll();\n        };\n        window.addEventListener(\"resize\", handleResize);\n        window.addEventListener(\"scroll\", handleScroll, {\n            passive: true\n        });\n        // Add wheel event listener to the container\n        window.addEventListener(\"wheel\", handleWheel, {\n            passive: true\n        });\n        // Add touch events for mobile\n        window.addEventListener(\"touchstart\", handleTouchStart, {\n            passive: true\n        });\n        window.addEventListener(\"touchmove\", handleTouchMove, {\n            passive: true\n        });\n        window.addEventListener(\"touchend\", handleTouchEnd, {\n            passive: true\n        });\n        // Initial rotation and position\n        targetRotationY = 0.5;\n        planet.rotation.y = 0.5;\n        atmosphere.rotation.y = 0.5;\n        // Set initial target positions (actual planet movement will be done smoothly in animation loop)\n        targetX = 20;\n        targetZ = 30;\n        planet.position.set(20, 0, 30); // Set initial position to match targets\n        atmosphere.position.copy(planet.position);\n        // Start animation\n        animate();\n        // Create an IntersectionObserver to rotate the planet when page sections come into view\n        // This provides a backup method in case wheel events don't work well\n        setTimeout(()=>{\n            const sections = document.querySelectorAll(\"section\");\n            if (sections.length > 0) {\n                let currentSectionIndex = 0;\n                const sectionObserver = new IntersectionObserver((entries)=>{\n                    entries.forEach((entry)=>{\n                        if (entry.isIntersecting) {\n                            // Get the section index\n                            const section = entry.target;\n                            const index = Array.from(sections).indexOf(section);\n                            // Determine rotation based on section index\n                            // Ensure we only rotate if we're moving to a new section\n                            if (index !== currentSectionIndex) {\n                                // Set target rotation - actual rotation will happen smoothly in animation loop\n                                targetRotationY = Math.PI / 2 * index;\n                                currentSectionIndex = index;\n                            }\n                        }\n                    });\n                }, {\n                    threshold: 0.3\n                }); // Trigger when 30% of section is visible\n                // Observe all sections\n                sections.forEach((section)=>{\n                    sectionObserver.observe(section);\n                });\n            }\n        }, 1000); // Wait for sections to be ready\n        // Cleanup\n        return ()=>{\n            var _containerRef_current;\n            window.removeEventListener(\"resize\", handleResize);\n            window.removeEventListener(\"wheel\", handleWheel);\n            window.removeEventListener(\"touchstart\", handleTouchStart);\n            window.removeEventListener(\"touchmove\", handleTouchMove);\n            window.removeEventListener(\"touchend\", handleTouchEnd);\n            (_containerRef_current = containerRef.current) === null || _containerRef_current === void 0 ? void 0 : _containerRef_current.removeChild(renderer.domElement);\n            renderer.dispose();\n        };\n    }, []);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: containerRef,\n        style: {\n            position: \"fixed\",\n            top: 0,\n            left: 0,\n            width: \"100%\",\n            height: \"100%\",\n            zIndex: 1\n        }\n    }, void 0, false, {\n        fileName: \"/Users/kaistephens/Downloads/code/florAI/webApp/FlorAI/src/components/PlanetScene.tsx\",\n        lineNumber: 371,\n        columnNumber: 9\n    }, this);\n}\n_s(PlanetScene, \"8puyVO4ts1RhCfXUmci3vLI3Njw=\");\n_c = PlanetScene;\nvar _c;\n$RefreshReg$(_c, \"PlanetScene\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL1BsYW5ldFNjZW5lLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBRTBDO0FBQ1g7QUFHaEIsU0FBU0c7O0lBQ3BCLE1BQU1DLGVBQWVILDZDQUFNQSxDQUFpQjtJQUU1Q0QsZ0RBQVNBLENBQUM7UUFDTixJQUFJLENBQUNJLGFBQWFDLE9BQU8sRUFBRTtRQUUzQixjQUFjO1FBQ2QsTUFBTUMsUUFBUSxJQUFJSix3Q0FBVztRQUU3QixvQkFBb0I7UUFDcEJJLE1BQU1FLEdBQUcsR0FBRyxJQUFJTiwwQ0FBYSxDQUFDLFVBQVU7UUFFeEMseURBQXlEO1FBQ3pELE1BQU1RLFNBQVMsSUFBSVIsb0RBQXVCLENBQUMsSUFBSVUsT0FBT0MsVUFBVSxHQUFHRCxPQUFPRSxXQUFXLEVBQUUsS0FBSztRQUU1Rix3Q0FBd0M7UUFDeEMsTUFBTUMsV0FBVyxJQUFJYixnREFBbUIsQ0FBQztZQUNyQ2UsV0FBVztZQUNYQyxPQUFPO1FBQ1g7UUFDQUgsU0FBU0ksT0FBTyxDQUFDUCxPQUFPQyxVQUFVLEVBQUVELE9BQU9FLFdBQVc7UUFDdERDLFNBQVNLLGFBQWEsQ0FBQztRQUN2QkwsU0FBU00sV0FBVyxHQUFHbkIsd0RBQTJCO1FBQ2xEYSxTQUFTUSxtQkFBbUIsR0FBRztRQUMvQm5CLGFBQWFDLE9BQU8sQ0FBQ21CLFdBQVcsQ0FBQ1QsU0FBU1UsVUFBVTtRQUVwRCxvQkFBb0I7UUFDcEIsTUFBTUMsZUFBZSxJQUFJeEIsK0NBQWtCLENBQUMsVUFBVTtRQUN0REksTUFBTXNCLEdBQUcsQ0FBQ0Y7UUFFVixNQUFNRyxhQUFhLElBQUkzQiw2Q0FBZ0IsQ0FBQyxVQUFVO1FBQ2xEMkIsV0FBV0UsUUFBUSxDQUFDQyxHQUFHLENBQUMsSUFBSSxHQUFHLEtBQUssaURBQWlEO1FBQ3JGMUIsTUFBTXNCLEdBQUcsQ0FBQ0M7UUFFVixtREFBbUQ7UUFDbkQsTUFBTUksY0FBYyxJQUFJL0IsNkNBQWdCLENBQUMsVUFB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QUNKLEdBQUcsT0FBTyxnQ0FBZ0M7UUFFMUMsVUFBVTtRQUNWLE9BQU87Z0JBTUhySTtZQUxBUSxPQUFPc0ksbUJBQW1CLENBQUMsVUFBVXhCO1lBQ3JDOUcsT0FBT3NJLG1CQUFtQixDQUFDLFNBQVMvQztZQUNwQ3ZGLE9BQU9zSSxtQkFBbUIsQ0FBQyxjQUFjdkM7WUFDekMvRixPQUFPc0ksbUJBQW1CLENBQUMsYUFBYXBDO1lBQ3hDbEcsT0FBT3NJLG1CQUFtQixDQUFDLFlBQVlsQzthQUN2QzVHLHdCQUFBQSxhQUFhQyxPQUFPLGNBQXBCRCw0Q0FBQUEsc0JBQXNCK0ksV0FBVyxDQUFDcEksU0FBU1UsVUFBVTtZQUNyRFYsU0FBU3FJLE9BQU87UUFDcEI7SUFDSixHQUFHLEVBQUU7SUFFTCxxQkFDSSw4REFBQ0M7UUFDR0MsS0FBS2xKO1FBQ0xtSixPQUFPO1lBQ0h4SCxVQUFVO1lBQ1Z5SCxLQUFLO1lBQ0xDLE1BQU07WUFDTkMsT0FBTztZQUNQQyxRQUFRO1lBQ1JDLFFBQVE7UUFDWjs7Ozs7O0FBR1o7R0F4WHdCeko7S0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvUGxhbmV0U2NlbmUudHN4PzlhMTYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xuXG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCAqIGFzIFRIUkVFIGZyb20gJ3RocmVlJztcbmltcG9ydCB7IE9yYml0Q29udHJvbHMgfSBmcm9tICd0aHJlZS9leGFtcGxlcy9qc20vY29udHJvbHMvT3JiaXRDb250cm9scyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFBsYW5ldFNjZW5lKCkge1xuICAgIGNvbnN0IGNvbnRhaW5lclJlZiA9IHVzZVJlZjxIVE1MRGl2RWxlbWVudD4obnVsbCk7XG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIWNvbnRhaW5lclJlZi5jdXJyZW50KSByZXR1cm47XG5cbiAgICAgICAgLy8gU2NlbmUgc2V0dXBcbiAgICAgICAgY29uc3Qgc2NlbmUgPSBuZXcgVEhSRUUuU2NlbmUoKTtcbiAgICAgICAgXG4gICAgICAgIC8vIEFkZCBmb2cgZm9yIGRlcHRoXG4gICAgICAgIHNjZW5lLmZvZyA9IG5ldyBUSFJFRS5Gb2dFeHAyKDB4MDAwNTExLCAwLjAxKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFVzZSBhIHdpZGVyIGZpZWxkIG9mIHZpZXcgdG8gY2FwdHVyZSBtb3JlIG9mIHRoZSBzY2VuZVxuICAgICAgICBjb25zdCBjYW1lcmEgPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoNjAsIHdpbmRvdy5pbm5lcldpZHRoIC8gd2luZG93LmlubmVySGVpZ2h0LCAwLjEsIDEwMDApO1xuICAgICAgICBcbiAgICAgICAgLy8gRW5oYW5jZWQgcmVuZGVyZXIgd2l0aCBiZXR0ZXIgc2hhZG93c1xuICAgICAgICBjb25zdCByZW5kZXJlciA9IG5ldyBUSFJFRS5XZWJHTFJlbmRlcmVyKHsgXG4gICAgICAgICAgICBhbnRpYWxpYXM6IHRydWUsXG4gICAgICAgICAgICBhbHBoYTogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJlbmRlcmVyLnNldFNpemUod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCk7XG4gICAgICAgIHJlbmRlcmVyLnNldENsZWFyQ29sb3IoMHgwMDA1MTEpO1xuICAgICAgICByZW5kZXJlci50b25lTWFwcGluZyA9IFRIUkVFLkFDRVNGaWxtaWNUb25lTWFwcGluZztcbiAgICAgICAgcmVuZGVyZXIudG9uZU1hcHBpbmdFeHBvc3VyZSA9IDEuMjtcbiAgICAgICAgY29udGFpbmVyUmVmLmN1cnJlbnQuYXBwZW5kQ2hpbGQocmVuZGVyZXIuZG9tRWxlbWVudCk7XG5cbiAgICAgICAgLy8gRW5oYW5jZWQgTGlnaHRpbmdcbiAgICAgICAgY29uc3QgYW1iaWVudExpZ2h0ID0gbmV3IFRIUkVFLkFtYmllbnRMaWdodCgweGZmZmZmZiwgMC44KTtcbiAgICAgICAgc2NlbmUuYWRkKGFtYmllbnRMaWdodCk7XG5cbiAgICAgICAgY29uc3QgcG9pbnRMaWdodCA9IG5ldyBUSFJFRS5Qb2ludExpZ2h0KDB4ZmZmZmZmLCAyKTtcbiAgICAgICAgcG9pbnRMaWdodC5wb3NpdGlvbi5zZXQoMjUsIDUsIDE1KTsgLy8gUG9zaXRpb24gbGlnaHQgdG8gaWxsdW1pbmF0ZSBwbGFuZXQgZnJvbSByaWdodFxuICAgICAgICBzY2VuZS5hZGQocG9pbnRMaWdodCk7XG5cbiAgICAgICAgLy8gQWRkIGEgc2Vjb25kIHBvaW50IGxpZ2h0IGZvciBiZXR0ZXIgaWxsdW1pbmF0aW9uXG4gICAgICAgIGNvbnN0IHBvaW50TGlnaHQyID0gbmV3IFRIUkVFLlBvaW50TGlnaHQoMHhjNGYxZGUsIDEuNSk7XG4gICAgICAgIHBvaW50TGlnaHQyLnBvc2l0aW9uLnNldCgtMTAsIC01LCAtNSk7XG4gICAgICAgIHNjZW5lLmFkZChwb2ludExpZ2h0Mik7XG5cbiAgICAgICAgLy8gQ3JlYXRlIHN0YXJzIC0gc2ltcGxlIGFuZCBzcHJlYWQgdGhyb3VnaG91dCB0aGUgc2NlbmVcbiAgICAgICAgY29uc3QgY3JlYXRlU3RhckZpZWxkID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3RhckNvdW50ID0gMzAwMDtcbiAgICAgICAgICAgIGNvbnN0IGdlb21ldHJ5ID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCk7XG4gICAgICAgICAgICBjb25zdCBwb3NpdGlvbnMgPSBuZXcgRmxvYXQzMkFycmF5KHN0YXJDb3VudCAqIDMpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBDcmVhdGUgc3RhcnMgd2l0aCBhIHdpZGVyIGRpc3RyaWJ1dGlvblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGFyQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgIC8vIERpc3RyaWJ1dGUgc3RhcnMgaW4gYSBjdWJlIGZvcm1hdGlvbiB0aGF0IGV4dGVuZHMgd2VsbCBiZXlvbmQgdGhlIGNhbWVyYSB2aWV3XG4gICAgICAgICAgICAgICAgcG9zaXRpb25zW2kgKiAzXSA9IChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDIwMDtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbnNbaSAqIDMgKyAxXSA9IChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDIwMDtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbnNbaSAqIDMgKyAyXSA9IChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDIwMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCdwb3NpdGlvbicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUocG9zaXRpb25zLCAzKSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFVzZSBhIHNpbmdsZSBzdGFyIHNpemUgaW5zdGVhZCBvZiBkaWZmZXJlbnQgc2l6ZXNcbiAgICAgICAgICAgIGNvbnN0IG1hdGVyaWFsID0gbmV3IFRIUkVFLlBvaW50c01hdGVyaWFsKHsgXG4gICAgICAgICAgICAgICAgY29sb3I6IDB4ZmZmZmZmLCBcbiAgICAgICAgICAgICAgICBzaXplOiAwLjIsIC8vIFNtYWxsZXIsIGVxdWFsLXNpemVkIHN0YXJzXG4gICAgICAgICAgICAgICAgdHJhbnNwYXJlbnQ6IHRydWUsIFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDAuOCBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCBzdGFycyA9IG5ldyBUSFJFRS5Qb2ludHMoZ2VvbWV0cnksIG1hdGVyaWFsKTtcbiAgICAgICAgICAgIHNjZW5lLmFkZChzdGFycyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHJldHVybiBbc3RhcnNdOyAvLyBSZXR1cm4gYXMgYW4gYXJyYXkgdG8gbWFpbnRhaW4gY29tcGF0aWJpbGl0eSB3aXRoIGFuaW1hdGlvbiBjb2RlXG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICBjb25zdCBzdGFyR3JvdXBzID0gY3JlYXRlU3RhckZpZWxkKCk7XG5cbiAgICAgICAgLy8gQ3JlYXRlIHBsYW5ldCAob24gdGhlIHJpZ2h0IHNpZGUpXG4gICAgICAgIGNvbnN0IHBsYW5ldEdlb21ldHJ5ID0gbmV3IFRIUkVFLlNwaGVyZUdlb21ldHJ5KDEyLCA2NCwgNjQpO1xuICAgICAgICBjb25zdCBwbGFuZXRNYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbCh7XG4gICAgICAgICAgICBtYXA6IG5ldyBUSFJFRS5UZXh0dXJlTG9hZGVyKCkubG9hZCgnaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL21yZG9vYi90aHJlZS5qcy9kZXYvZXhhbXBsZXMvdGV4dHVyZXMvcGxhbmV0cy9lYXJ0aF9hdG1vc18yMDQ4LmpwZycpLFxuICAgICAgICAgICAgYnVtcE1hcDogbmV3IFRIUkVFLlRleHR1cmVMb2FkZXIoKS5sb2FkKCdodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vbXJkb29iL3RocmVlLmpzL2Rldi9leGFtcGxlcy90ZXh0dXJlcy9wbGFuZXRzL2VhcnRoX25vcm1hbF8yMDQ4LmpwZycpLFxuICAgICAgICAgICAgYnVtcFNjYWxlOiAwLjA1LFxuICAgICAgICAgICAgc3BlY3VsYXJNYXA6IG5ldyBUSFJFRS5UZXh0dXJlTG9hZGVyKCkubG9hZCgnaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL21yZG9vYi90aHJlZS5qcy9kZXYvZXhhbXBsZXMvdGV4dHVyZXMvcGxhbmV0cy9lYXJ0aF9zcGVjdWxhcl8yMDQ4LmpwZycpLFxuICAgICAgICAgICAgc3BlY3VsYXI6IG5ldyBUSFJFRS5Db2xvcignZ3JleScpLFxuICAgICAgICAgICAgc2hpbmluZXNzOiAxNVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcGxhbmV0ID0gbmV3IFRIUkVFLk1lc2gocGxhbmV0R2VvbWV0cnksIHBsYW5ldE1hdGVyaWFsKTtcbiAgICAgICAgc2NlbmUuYWRkKHBsYW5ldCk7XG5cbiAgICAgICAgLy8gQWRkIHBsYW50LWxpa2UgYXRtb3NwaGVyZVxuICAgICAgICBjb25zdCBhdG1vc3BoZXJlR2VvbWV0cnkgPSBuZXcgVEhSRUUuU3BoZXJlR2VvbWV0cnkoMTIuNCwgNjQsIDY0KTtcbiAgICAgICAgY29uc3QgYXRtb3NwaGVyZU1hdGVyaWFsID0gbmV3IFRIUkVFLlNoYWRlck1hdGVyaWFsKHtcbiAgICAgICAgICAgIHRyYW5zcGFyZW50OiB0cnVlLFxuICAgICAgICAgICAgc2lkZTogVEhSRUUuQmFja1NpZGUsXG4gICAgICAgICAgICB2ZXJ0ZXhTaGFkZXI6IGBcbiAgICAgICAgICAgICAgICB2YXJ5aW5nIHZlYzMgdk5vcm1hbDtcbiAgICAgICAgICAgICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZOb3JtYWwgPSBub3JtYWxpemUobm9ybWFsTWF0cml4ICogbm9ybWFsKTtcbiAgICAgICAgICAgICAgICAgICAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNChwb3NpdGlvbiwgMS4wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBgLFxuICAgICAgICAgICAgZnJhZ21lbnRTaGFkZXI6IGBcbiAgICAgICAgICAgICAgICB2YXJ5aW5nIHZlYzMgdk5vcm1hbDtcbiAgICAgICAgICAgICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IGludGVuc2l0eSA9IHBvdygwLjcgLSBkb3Qodk5vcm1hbCwgdmVjMygwLjAsIDAuMCwgMS4wKSksIDIuMCk7XG4gICAgICAgICAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMC40LCAwLjgsIDAuNCwgMS4wKSAqIGludGVuc2l0eTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBgXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBhdG1vc3BoZXJlID0gbmV3IFRIUkVFLk1lc2goYXRtb3NwaGVyZUdlb21ldHJ5LCBhdG1vc3BoZXJlTWF0ZXJpYWwpO1xuICAgICAgICBzY2VuZS5hZGQoYXRtb3NwaGVyZSk7XG5cbiAgICAgICAgLy8gQ2FtZXJhIHBvc2l0aW9uIC0gYWRqdXN0ZWQgZm9yIHRoZSBtdWNoIGxhcmdlciBhbmQgZnVydGhlci1yaWdodCBwbGFuZXRcbiAgICAgICAgY2FtZXJhLnBvc2l0aW9uLnNldCgtMjAsIDAsIDI1KTtcbiAgICAgICAgLy8gTG9vayBhdCBhIHBvaW50IG11Y2ggZnVydGhlciB0byB0aGUgcmlnaHRcbiAgICAgICAgY2FtZXJhLmxvb2tBdChuZXcgVEhSRUUuVmVjdG9yMyg2MCwgMCwgMCkpO1xuXG4gICAgICAgIC8vIEFuaW1hdGlvblxuICAgICAgICAvLyBUcmFjayB0YXJnZXQgcG9zaXRpb25zIGZvciBzbW9vdGhlciBpbnRlcnBvbGF0aW9uXG4gICAgICAgIGxldCB0YXJnZXRYID0gMjA7XG4gICAgICAgIGxldCB0YXJnZXRaID0gMzA7XG4gICAgICAgIGxldCB0YXJnZXRSb3RhdGlvblkgPSAwLjU7IC8vIEFkZCB0YXJnZXQgcm90YXRpb24gZm9yIHNtb290aCB0cmFuc2l0aW9uc1xuICAgICAgICBjb25zdCBpbnRlcnBvbGF0aW9uU3BlZWQgPSAwLjA1OyAvLyBDb250cm9scyBzbW9vdGhuZXNzIG9mIHRyYW5zaXRpb25zXG4gICAgICAgIFxuICAgICAgICAvLyBUcmFjayBkaXJlY3Rpb24gZm9yIHotcG9zaXRpb24gb3NjaWxsYXRpb25cbiAgICAgICAgbGV0IHpEaXJlY3Rpb25Gb3J3YXJkID0gdHJ1ZTsgLy8gdHJ1ZSA9IG1vdmluZyB0b3dhcmQgdmlld2VyIChkZWNyZWFzaW5nIHopLCBmYWxzZSA9IG1vdmluZyBhd2F5XG4gICAgICAgIGxldCBhdXRvT3NjaWxsYXRlID0gZmFsc2U7IC8vIFdpbGwgYmUgc2V0IHRvIHRydWUgb25jZSB0YXJnZXQgcmVhY2hlcyBhIGJvdW5kYXJ5XG4gICAgICAgIGNvbnN0IG9zY2lsbGF0aW9uU3BlZWQgPSAwLjE7IC8vIFNwZWVkIG9mIGF1dG9tYXRpYyBiYWNrLWFuZC1mb3J0aCBtb3ZlbWVudFxuICAgICAgICBcbiAgICAgICAgZnVuY3Rpb24gYW5pbWF0ZSgpIHtcbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRlKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gU21vb3RobHkgaW50ZXJwb2xhdGUgY3VycmVudCBwb3NpdGlvbiB0b3dhcmQgdGFyZ2V0IHBvc2l0aW9uXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50WCA9IHBsYW5ldC5wb3NpdGlvbi54O1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFogPSBwbGFuZXQucG9zaXRpb24uejtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gSW50ZXJwb2xhdGUgWCBwb3NpdGlvbiAocmlnaHQgbW92ZW1lbnQpXG4gICAgICAgICAgICBpZiAoTWF0aC5hYnModGFyZ2V0WCAtIGN1cnJlbnRYKSA+IDAuMDEpIHtcbiAgICAgICAgICAgICAgICBwbGFuZXQucG9zaXRpb24ueCArPSAodGFyZ2V0WCAtIGN1cnJlbnRYKSAqIGludGVycG9sYXRpb25TcGVlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gSGFuZGxlIHotcG9zaXRpb24gb3NjaWxsYXRpb25cbiAgICAgICAgICAgIGlmIChhdXRvT3NjaWxsYXRlKSB7XG4gICAgICAgICAgICAgICAgLy8gQXV0b21hdGljYWxseSBtb3ZlIGluIGN1cnJlbnQgZGlyZWN0aW9uXG4gICAgICAgICAgICAgICAgaWYgKHpEaXJlY3Rpb25Gb3J3YXJkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFogLT0gb3NjaWxsYXRpb25TcGVlZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldFogPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0WiA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB6RGlyZWN0aW9uRm9yd2FyZCA9IGZhbHNlOyAvLyBSZXZlcnNlIGRpcmVjdGlvblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0WiArPSBvc2NpbGxhdGlvblNwZWVkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0WiA+PSAzMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0WiA9IDMwO1xuICAgICAgICAgICAgICAgICAgICAgICAgekRpcmVjdGlvbkZvcndhcmQgPSB0cnVlOyAvLyBSZXZlcnNlIGRpcmVjdGlvblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB3ZSd2ZSByZWFjaGVkIGEgYm91bmRhcnkgYW5kIHNob3VsZCBzdGFydCBhdXRvLW9zY2lsbGF0aW9uXG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldFogPD0gMC4xKSB7XG4gICAgICAgICAgICAgICAgICAgIHpEaXJlY3Rpb25Gb3J3YXJkID0gZmFsc2U7IC8vIFN0YXJ0IG1vdmluZyBhd2F5XG4gICAgICAgICAgICAgICAgICAgIGF1dG9Pc2NpbGxhdGUgPSB0cnVlOyAvLyBCZWdpbiBhdXRvLW9zY2lsbGF0aW9uXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0YXJnZXRaID49IDI5LjkpIHtcbiAgICAgICAgICAgICAgICAgICAgekRpcmVjdGlvbkZvcndhcmQgPSB0cnVlOyAvLyBTdGFydCBtb3ZpbmcgdG93YXJkIHZpZXdlclxuICAgICAgICAgICAgICAgICAgICBhdXRvT3NjaWxsYXRlID0gdHJ1ZTsgLy8gQmVnaW4gYXV0by1vc2NpbGxhdGlvblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gSW50ZXJwb2xhdGUgWiBwb3NpdGlvbiAoZGlzdGFuY2UpXG4gICAgICAgICAgICBpZiAoTWF0aC5hYnModGFyZ2V0WiAtIGN1cnJlbnRaKSA+IDAuMDEpIHtcbiAgICAgICAgICAgICAgICBwbGFuZXQucG9zaXRpb24ueiArPSAodGFyZ2V0WiAtIGN1cnJlbnRaKSAqIGludGVycG9sYXRpb25TcGVlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gSW50ZXJwb2xhdGUgcm90YXRpb24gZm9yIHNtb290aCB0cmFuc2l0aW9uc1xuICAgICAgICAgICAgY29uc3Qgcm90YXRpb25EZWx0YSA9IHRhcmdldFJvdGF0aW9uWSAtIHBsYW5ldC5yb3RhdGlvbi55O1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHJvdGF0aW9uRGVsdGEpID4gMC4wMSkge1xuICAgICAgICAgICAgICAgIHBsYW5ldC5yb3RhdGlvbi55ICs9IHJvdGF0aW9uRGVsdGEgKiBpbnRlcnBvbGF0aW9uU3BlZWQ7XG4gICAgICAgICAgICAgICAgYXRtb3NwaGVyZS5yb3RhdGlvbi55ID0gcGxhbmV0LnJvdGF0aW9uLnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEtlZXAgYXRtb3NwaGVyZSB3aXRoIHBsYW5ldFxuICAgICAgICAgICAgYXRtb3NwaGVyZS5wb3NpdGlvbi5jb3B5KHBsYW5ldC5wb3NpdGlvbik7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFJvdGF0ZSBzdGFyIGZpZWxkcyBzbGlnaHRseSBmb3Igc3VidGxlIG1vdmVtZW50XG4gICAgICAgICAgICBzdGFyR3JvdXBzLmZvckVhY2goKHN0YXJzLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgc3RhcnMucm90YXRpb24ueSArPSAwLjAwMDEgKiAoaSArIDEpO1xuICAgICAgICAgICAgICAgIHN0YXJzLnJvdGF0aW9uLnggKz0gMC4wMDAwNSAqIChpICsgMSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcmVuZGVyZXIucmVuZGVyKHNjZW5lLCBjYW1lcmEpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBIYW5kbGUgd2hlZWwgZXZlbnRzIGZvciByb3RhdGlvbiAtIHRoaXMgaXMgbW9yZSBkaXJlY3QgdGhhbiBzY3JvbGxcbiAgICAgICAgY29uc3QgaGFuZGxlV2hlZWwgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIC8vIERldGVybWluZSBkaXJlY3Rpb24gYW5kIGZvcmNlIG9mIHdoZWVsIGV2ZW50XG4gICAgICAgICAgICBjb25zdCBkZWx0YSA9IGV2ZW50LmRlbHRhWTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQXBwbHkgcm90YXRpb24gZGlyZWN0bHkgdG8gdGhlIHBsYW5ldCAodmlhIHRhcmdldClcbiAgICAgICAgICAgIHRhcmdldFJvdGF0aW9uWSArPSBkZWx0YSAqIDAuMDAyO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBDaGVjayBzY3JvbGwgZGlyZWN0aW9uIC0gbWFudWFsIGNvbnRyb2wgdGVtcG9yYXJpbHkgb3ZlcnJpZGVzIGF1dG8tb3NjaWxsYXRpb25cbiAgICAgICAgICAgIGlmIChkZWx0YSA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBTY3JvbGxpbmcgZG93biAtIG1vdmUgcGxhbmV0IGNsb3NlciAoZGVjcmVhc2UgeikgLSBmYXN0ZXJcbiAgICAgICAgICAgICAgICBhdXRvT3NjaWxsYXRlID0gZmFsc2U7IC8vIERpc2FibGUgYXV0by1vc2NpbGxhdGlvbiBkdXJpbmcgbWFudWFsIGNvbnRyb2xcbiAgICAgICAgICAgICAgICB6RGlyZWN0aW9uRm9yd2FyZCA9IHRydWU7IC8vIFNldCBkaXJlY3Rpb24gdG93YXJkIHZpZXdlclxuICAgICAgICAgICAgICAgIGlmICh0YXJnZXRaID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBEZWNyZWFzZSB6IHByb3BvcnRpb25hbCB0byByb3RhdGlvbiBhbW91bnQgYnV0IGFsd2F5cyBtb3ZpbmcgZm9yd2FyZFxuICAgICAgICAgICAgICAgICAgICBjb25zdCB6RGVsdGEgPSBNYXRoLmFicyhkZWx0YSkgKiAwLjAzO1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRaID0gTWF0aC5tYXgoMCwgdGFyZ2V0WiAtIHpEZWx0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChkZWx0YSA8IDApIHtcbiAgICAgICAgICAgICAgICAvLyBTY3JvbGxpbmcgdXAgLSBtb3ZlIHBsYW5ldCBmYXJ0aGVyIChpbmNyZWFzZSB6KVxuICAgICAgICAgICAgICAgIGF1dG9Pc2NpbGxhdGUgPSBmYWxzZTsgLy8gRGlzYWJsZSBhdXRvLW9zY2lsbGF0aW9uIGR1cmluZyBtYW51YWwgY29udHJvbFxuICAgICAgICAgICAgICAgIHpEaXJlY3Rpb25Gb3J3YXJkID0gZmFsc2U7IC8vIFNldCBkaXJlY3Rpb24gYXdheSBmcm9tIHZpZXdlclxuICAgICAgICAgICAgICAgIGlmICh0YXJnZXRaIDwgMzApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW5jcmVhc2UgeiBwcm9wb3J0aW9uYWwgdG8gcm90YXRpb24gYW1vdW50XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHpEZWx0YSA9IE1hdGguYWJzKGRlbHRhKSAqIDAuMDM7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFogPSBNYXRoLm1pbigzMCwgdGFyZ2V0WiArIHpEZWx0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgLy8gVHJhY2sgdG91Y2ggcG9zaXRpb24gZm9yIG1vYmlsZSBkZXZpY2VzXG4gICAgICAgIGxldCB0b3VjaFN0YXJ0WSA9IDA7XG4gICAgICAgIFxuICAgICAgICAvLyBIYW5kbGUgdG91Y2ggZXZlbnRzIGZvciBtb2JpbGVcbiAgICAgICAgY29uc3QgaGFuZGxlVG91Y2hTdGFydCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdG91Y2hTdGFydFkgPSBldmVudC50b3VjaGVzWzBdLmNsaWVudFk7XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICBjb25zdCBoYW5kbGVUb3VjaE1vdmUgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIC8vIFNraXAgaWYgbm8gc3RhcnRpbmcgcG9zaXRpb25cbiAgICAgICAgICAgIGlmICh0b3VjaFN0YXJ0WSA9PT0gMCkgcmV0dXJuO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgZGVsdGEgKG5lZ2F0aXZlIHRvIG1hdGNoIHdoZWVsIGRpcmVjdGlvbilcbiAgICAgICAgICAgIGNvbnN0IHRvdWNoRGVsdGEgPSAtKGV2ZW50LnRvdWNoZXNbMF0uY2xpZW50WSAtIHRvdWNoU3RhcnRZKSAqIDEwO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBBcHBseSByb3RhdGlvbiBqdXN0IGxpa2Ugd2l0aCB3aGVlbCBldmVudHNcbiAgICAgICAgICAgIHRhcmdldFJvdGF0aW9uWSArPSB0b3VjaERlbHRhICogMC4wMDI7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIENoZWNrIHNjcm9sbCBkaXJlY3Rpb24gLSBtYW51YWwgY29udHJvbCB0ZW1wb3JhcmlseSBvdmVycmlkZXMgYXV0by1vc2NpbGxhdGlvblxuICAgICAgICAgICAgaWYgKHRvdWNoRGVsdGEgPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gU2Nyb2xsaW5nIGRvd24gLSBtb3ZlIHBsYW5ldCBjbG9zZXIgKGRlY3JlYXNlIHopXG4gICAgICAgICAgICAgICAgYXV0b09zY2lsbGF0ZSA9IGZhbHNlOyAvLyBEaXNhYmxlIGF1dG8tb3NjaWxsYXRpb24gZHVyaW5nIG1hbnVhbCBjb250cm9sXG4gICAgICAgICAgICAgICAgekRpcmVjdGlvbkZvcndhcmQgPSB0cnVlOyAvLyBTZXQgZGlyZWN0aW9uIHRvd2FyZCB2aWV3ZXJcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0WiA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRGVjcmVhc2UgeiBwcm9wb3J0aW9uYWwgdG8gcm90YXRpb24gYW1vdW50XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHpEZWx0YSA9IE1hdGguYWJzKHRvdWNoRGVsdGEpICogMC4wMztcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0WiA9IE1hdGgubWF4KDAsIHRhcmdldFogLSB6RGVsdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodG91Y2hEZWx0YSA8IDApIHtcbiAgICAgICAgICAgICAgICAvLyBTY3JvbGxpbmcgdXAgLSBtb3ZlIHBsYW5ldCBmYXJ0aGVyIChpbmNyZWFzZSB6KVxuICAgICAgICAgICAgICAgIGF1dG9Pc2NpbGxhdGUgPSBmYWxzZTsgLy8gRGlzYWJsZSBhdXRvLW9zY2lsbGF0aW9uIGR1cmluZyBtYW51YWwgY29udHJvbFxuICAgICAgICAgICAgICAgIHpEaXJlY3Rpb25Gb3J3YXJkID0gZmFsc2U7IC8vIFNldCBkaXJlY3Rpb24gYXdheSBmcm9tIHZpZXdlclxuICAgICAgICAgICAgICAgIGlmICh0YXJnZXRaIDwgMzApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW5jcmVhc2UgeiBwcm9wb3J0aW9uYWwgdG8gcm90YXRpb24gYW1vdW50XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHpEZWx0YSA9IE1hdGguYWJzKHRvdWNoRGVsdGEpICogMC4wMztcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0WiA9IE1hdGgubWluKDMwLCB0YXJnZXRaICsgekRlbHRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBzdGFydCBwb3NpdGlvblxuICAgICAgICAgICAgdG91Y2hTdGFydFkgPSBldmVudC50b3VjaGVzWzBdLmNsaWVudFk7XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICBjb25zdCBoYW5kbGVUb3VjaEVuZCA9ICgpID0+IHtcbiAgICAgICAgICAgIHRvdWNoU3RhcnRZID0gMDtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBIYW5kbGUgc2Nyb2xsIGV2ZW50cyB0byB1cGRhdGUgcGxhbmV0IHBvc2l0aW9uXG4gICAgICAgIGNvbnN0IGhhbmRsZVNjcm9sbCA9ICgpID0+IHtcbiAgICAgICAgICAgIC8vIEdldCBjdXJyZW50IHNjcm9sbCBwb3NpdGlvbiBhcyBwZXJjZW50YWdlIG9mIHBhZ2UgaGVpZ2h0XG4gICAgICAgICAgICBjb25zdCBzY3JvbGxIZWlnaHQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsSGVpZ2h0IC0gd2luZG93LmlubmVySGVpZ2h0O1xuICAgICAgICAgICAgY29uc3Qgc2Nyb2xsVG9wID0gd2luZG93LnNjcm9sbFkgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcDtcbiAgICAgICAgICAgIGNvbnN0IHNjcm9sbFBlcmNlbnQgPSBNYXRoLm1pbihzY3JvbGxUb3AgLyBzY3JvbGxIZWlnaHQsIDEpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgeC1wb3NpdGlvbjogMjAgYXQgdG9wIG9mIHBhZ2UsIGdyYWR1YWxseSBpbmNyZWFzaW5nIHRvIDEwMCBhcyB3ZSBzY3JvbGxcbiAgICAgICAgICAgIGxldCB4UG9zID0gMjA7XG4gICAgICAgICAgICBpZiAoc2Nyb2xsUGVyY2VudCA+IDAuMSkge1xuICAgICAgICAgICAgICAgIC8vIE1hcCAxMCUtMzAlIHNjcm9sbCB0byBmdWxsIHgtcG9zaXRpb24gY2hhbmdlICgyMCB0byAxMDApIC0gbXVjaCBmYXN0ZXJcbiAgICAgICAgICAgICAgICAvLyBEZWNyZWFzZWQgZnJvbSAwLjQgdG8gMC4yIHRvIG1ha2UgaXQgbW92ZSBldmVuIGZhc3RlclxuICAgICAgICAgICAgICAgIGNvbnN0IHhTY3JvbGxQZXJjZW50ID0gTWF0aC5taW4oKHNjcm9sbFBlcmNlbnQgLSAwLjEpIC8gMC4yLCAxKTtcbiAgICAgICAgICAgICAgICB4UG9zID0gMjAgKyAoODAgKiB4U2Nyb2xsUGVyY2VudCk7IC8vIE1vdmUgZnJvbSAyMCB0byAxMDBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gVXBkYXRlIHRhcmdldCBYIHBvc2l0aW9uIC0gYWN0dWFsIG1vdmVtZW50IGhhcHBlbnMgaW4gYW5pbWF0aW9uIGxvb3BcbiAgICAgICAgICAgIHRhcmdldFggPSB4UG9zO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEhhbmRsZSB3aW5kb3cgcmVzaXplXG4gICAgICAgIGNvbnN0IGhhbmRsZVJlc2l6ZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGNhbWVyYS5hc3BlY3QgPSB3aW5kb3cuaW5uZXJXaWR0aCAvIHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICAgICAgICAgIGNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG4gICAgICAgICAgICByZW5kZXJlci5zZXRTaXplKHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBVcGRhdGUgcGxhbmV0IHBvc2l0aW9uIG9uIHJlc2l6ZSB0b29cbiAgICAgICAgICAgIGhhbmRsZVNjcm9sbCgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVSZXNpemUpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaGFuZGxlU2Nyb2xsLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgICAgIFxuICAgICAgICAvLyBBZGQgd2hlZWwgZXZlbnQgbGlzdGVuZXIgdG8gdGhlIGNvbnRhaW5lclxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignd2hlZWwnLCBoYW5kbGVXaGVlbCwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICAgICAgICBcbiAgICAgICAgLy8gQWRkIHRvdWNoIGV2ZW50cyBmb3IgbW9iaWxlXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgaGFuZGxlVG91Y2hTdGFydCwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgaGFuZGxlVG91Y2hNb3ZlLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIGhhbmRsZVRvdWNoRW5kLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgICAgIFxuICAgICAgICAvLyBJbml0aWFsIHJvdGF0aW9uIGFuZCBwb3NpdGlvblxuICAgICAgICB0YXJnZXRSb3RhdGlvblkgPSAwLjU7XG4gICAgICAgIHBsYW5ldC5yb3RhdGlvbi55ID0gMC41O1xuICAgICAgICBhdG1vc3BoZXJlLnJvdGF0aW9uLnkgPSAwLjU7XG4gICAgICAgIFxuICAgICAgICAvLyBTZXQgaW5pdGlhbCB0YXJnZXQgcG9zaXRpb25zIChhY3R1YWwgcGxhbmV0IG1vdmVtZW50IHdpbGwgYmUgZG9uZSBzbW9vdGhseSBpbiBhbmltYXRpb24gbG9vcClcbiAgICAgICAgdGFyZ2V0WCA9IDIwO1xuICAgICAgICB0YXJnZXRaID0gMzA7XG4gICAgICAgIHBsYW5ldC5wb3NpdGlvbi5zZXQoMjAsIDAsIDMwKTsgLy8gU2V0IGluaXRpYWwgcG9zaXRpb24gdG8gbWF0Y2ggdGFyZ2V0c1xuICAgICAgICBhdG1vc3BoZXJlLnBvc2l0aW9uLmNvcHkocGxhbmV0LnBvc2l0aW9uKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFN0YXJ0IGFuaW1hdGlvblxuICAgICAgICBhbmltYXRlKCk7XG5cbiAgICAgICAgLy8gQ3JlYXRlIGFuIEludGVyc2VjdGlvbk9ic2VydmVyIHRvIHJvdGF0ZSB0aGUgcGxhbmV0IHdoZW4gcGFnZSBzZWN0aW9ucyBjb21lIGludG8gdmlld1xuICAgICAgICAvLyBUaGlzIHByb3ZpZGVzIGEgYmFja3VwIG1ldGhvZCBpbiBjYXNlIHdoZWVsIGV2ZW50cyBkb24ndCB3b3JrIHdlbGxcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzZWN0aW9ucyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3NlY3Rpb24nKTtcbiAgICAgICAgICAgIGlmIChzZWN0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IGN1cnJlbnRTZWN0aW9uSW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGNvbnN0IHNlY3Rpb25PYnNlcnZlciA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcigoZW50cmllcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBlbnRyaWVzLmZvckVhY2goZW50cnkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVudHJ5LmlzSW50ZXJzZWN0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBzZWN0aW9uIGluZGV4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VjdGlvbiA9IGVudHJ5LnRhcmdldCBhcyBIVE1MRWxlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IEFycmF5LmZyb20oc2VjdGlvbnMpLmluZGV4T2Yoc2VjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIHJvdGF0aW9uIGJhc2VkIG9uIHNlY3Rpb24gaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFbnN1cmUgd2Ugb25seSByb3RhdGUgaWYgd2UncmUgbW92aW5nIHRvIGEgbmV3IHNlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggIT09IGN1cnJlbnRTZWN0aW9uSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2V0IHRhcmdldCByb3RhdGlvbiAtIGFjdHVhbCByb3RhdGlvbiB3aWxsIGhhcHBlbiBzbW9vdGhseSBpbiBhbmltYXRpb24gbG9vcFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRSb3RhdGlvblkgPSBNYXRoLlBJIC8gMiAqIGluZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2VjdGlvbkluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LCB7IHRocmVzaG9sZDogMC4zIH0pOyAvLyBUcmlnZ2VyIHdoZW4gMzAlIG9mIHNlY3Rpb24gaXMgdmlzaWJsZVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIE9ic2VydmUgYWxsIHNlY3Rpb25zXG4gICAgICAgICAgICAgICAgc2VjdGlvbnMuZm9yRWFjaChzZWN0aW9uID0+IHtcbiAgICAgICAgICAgICAgICAgICAgc2VjdGlvbk9ic2VydmVyLm9ic2VydmUoc2VjdGlvbik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIDEwMDApOyAvLyBXYWl0IGZvciBzZWN0aW9ucyB0byBiZSByZWFkeVxuXG4gICAgICAgIC8vIENsZWFudXBcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVSZXNpemUpO1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3doZWVsJywgaGFuZGxlV2hlZWwpO1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBoYW5kbGVUb3VjaFN0YXJ0KTtcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBoYW5kbGVUb3VjaE1vdmUpO1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgaGFuZGxlVG91Y2hFbmQpO1xuICAgICAgICAgICAgY29udGFpbmVyUmVmLmN1cnJlbnQ/LnJlbW92ZUNoaWxkKHJlbmRlcmVyLmRvbUVsZW1lbnQpO1xuICAgICAgICAgICAgcmVuZGVyZXIuZGlzcG9zZSgpO1xuICAgICAgICB9O1xuICAgIH0sIFtdKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxkaXYgXG4gICAgICAgICAgICByZWY9e2NvbnRhaW5lclJlZn0gXG4gICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnZml4ZWQnLFxuICAgICAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgICAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgICAgICAgICAgICAgekluZGV4OiAxXG4gICAgICAgICAgICB9fVxuICAgICAgICAvPlxuICAgICk7XG59ICJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJUSFJFRSIsIlBsYW5ldFNjZW5lIiwiY29udGFpbmVyUmVmIiwiY3VycmVudCIsInNjZW5lIiwiU2NlbmUiLCJmb2ciLCJGb2dFeHAyIiwiY2FtZXJhIiwiUGVyc3BlY3RpdmVDYW1lcmEiLCJ3aW5kb3ciLCJpbm5lcldpZHRoIiwiaW5uZXJIZWlnaHQiLCJyZW5kZXJlciIsIldlYkdMUmVuZGVyZXIiLCJhbnRpYWxpYXMiLCJhbHBoYSIsInNldFNpemUiLCJzZXRDbGVhckNvbG9yIiwidG9uZU1hcHBpbmciLCJBQ0VTRmlsbWljVG9uZU1hcHBpbmciLCJ0b25lTWFwcGluZ0V4cG9zdXJlIiwiYXBwZW5kQ2hpbGQiLCJkb21FbGVtZW50IiwiYW1iaWVudExpZ2h0IiwiQW1iaWVudExpZ2h0IiwiYWRkIiwicG9pbnRMaWdodCIsIlBvaW50TGlnaHQiLCJwb3NpdGlvbiIsInNldCIsInBvaW50TGlnaHQyIiwiY3JlYXRlU3RhckZpZWxkIiwic3RhckNvdW50IiwiZ2VvbWV0cnkiLCJCdWZmZXJHZW9tZXRyeSIsInBvc2l0aW9ucyIsIkZsb2F0MzJBcnJheSIsImkiLCJNYXRoIiwicmFuZG9tIiwic2V0QXR0cmlidXRlIiwiQnVmZmVyQXR0cmlidXRlIiwibWF0ZXJpYWwiLCJQb2ludHNNYXRlcmlhbCIsImNvbG9yIiwic2l6ZSIsInRyYW5zcGFyZW50Iiwib3BhY2l0eSIsInN0YXJzIiwiUG9pbnRzIiwic3Rhckdyb3VwcyIsInBsYW5ldEdlb21ldHJ5IiwiU3BoZXJlR2VvbWV0cnkiLCJwbGFuZXRNYXRlcmlhbCIsIk1lc2hQaG9uZ01hdGVyaWFsIiwibWFwIiwiVGV4dHVyZUxvYWRlciIsImxvYWQiLCJidW1wTWFwIiwiYnVtcFNjYWxlIiwic3BlY3VsYXJNYXAiLCJzcGVjdWxhciIsIkNvbG9yIiwic2hpbmluZXNzIiwicGxhbmV0IiwiTWVzaCIsImF0bW9zcGhlcmVHZW9tZXRyeSIsImF0bW9zcGhlcmVNYXRlcmlhbCIsIlNoYWRlck1hdGVyaWFsIiwic2lkZSIsIkJhY2tTaWRlIiwidmVydGV4U2hhZGVyIiwiZnJhZ21lbnRTaGFkZXIiLCJhdG1vc3BoZXJlIiwibG9va0F0IiwiVmVjdG9yMyIsInRhcmdldFgiLCJ0YXJnZXRaIiwidGFyZ2V0Um90YXRpb25ZIiwiaW50ZXJwb2xhdGlvblNwZWVkIiwiekRpcmVjdGlvbkZvcndhcmQiLCJhdXRvT3NjaWxsYXRlIiwib3NjaWxsYXRpb25TcGVlZCIsImFuaW1hdGUiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJjdXJyZW50WCIsIngiLCJjdXJyZW50WiIsInoiLCJhYnMiLCJyb3RhdGlvbkRlbHRhIiwicm90YXRpb24iLCJ5IiwiY29weSIsImZvckVhY2giLCJyZW5kZXIiLCJoYW5kbGVXaGVlbCIsImV2ZW50IiwiZGVsdGEiLCJkZWx0YVkiLCJ6RGVsdGEiLCJtYXgiLCJtaW4iLCJ0b3VjaFN0YXJ0WSIsImhhbmRsZVRvdWNoU3RhcnQiLCJ0b3VjaGVzIiwiY2xpZW50WSIsImhhbmRsZVRvdWNoTW92ZSIsInRvdWNoRGVsdGEiLCJoYW5kbGVUb3VjaEVuZCIsImhhbmRsZVNjcm9sbCIsInNjcm9sbEhlaWdodCIsImRvY3VtZW50IiwiZG9jdW1lbnRFbGVtZW50Iiwic2Nyb2xsVG9wIiwic2Nyb2xsWSIsInNjcm9sbFBlcmNlbnQiLCJ4UG9zIiwieFNjcm9sbFBlcmNlbnQiLCJoYW5kbGVSZXNpemUiLCJhc3BlY3QiLCJ1cGRhdGVQcm9qZWN0aW9uTWF0cml4IiwiYWRkRXZlbnRMaXN0ZW5lciIsInBhc3NpdmUiLCJzZXRUaW1lb3V0Iiwic2VjdGlvbnMiLCJxdWVyeVNlbGVjdG9yQWxsIiwibGVuZ3RoIiwiY3VycmVudFNlY3Rpb25JbmRleCIsInNlY3Rpb25PYnNlcnZlciIsIkludGVyc2VjdGlvbk9ic2VydmVyIiwiZW50cmllcyIsImVudHJ5IiwiaXNJbnRlcnNlY3RpbmciLCJzZWN0aW9uIiwidGFyZ2V0IiwiaW5kZXgiLCJBcnJheSIsImZyb20iLCJpbmRleE9mIiwiUEkiLCJ0aHJlc2hvbGQiLCJvYnNlcnZlIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInJlbW92ZUNoaWxkIiwiZGlzcG9zZSIsImRpdiIsInJlZiIsInN0eWxlIiwidG9wIiwibGVmdCIsIndpZHRoIiwiaGVpZ2h0IiwiekluZGV4Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/PlanetScene.tsx\n"));

/***/ })

});